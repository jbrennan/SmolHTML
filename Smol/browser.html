<h1>Let&rsquo;s Write a Web Browser from Scratch in Swift!</h1>

<p><em>April 2023</em></p>

<p>There&rsquo;s a rumour that Apple&rsquo;s going to start allowing custom, non-WebKit based browser engines on iOS starting later this year. While that most likely means Chrome, Firefox, and the other big browsers could start using custom engines, it also means you could write your own too. So why not try it?</p>

<p>In this 2 part series (<a href="https://nearthespeedoflight.com/browser-2.html">part 2 is here</a>), I&rsquo;ll take you through how to write a basic web browser from scratch, from parsing HTML in Swift to rendering the pages with SwiftUI, displaying them with a simple, but familiar interface.</p>

<p><img src="smol-screenshot.png" style="display: block" width="600"></p>

<p>You might be thinking &ldquo;Aren&rsquo;t web browsers huge, incredibly complicated pieces of software?&rdquo; and yes, the big ones we use every day are huge and complicated. But even huge and complicated pieces of software are still &ldquo;just software&rdquo; at their core, written by normal programmers just doing their job or following their passion. You can write one too.</p>

<p>What we&rsquo;re attempting in this series is a very simple browser, and the end result is actually a little under 1000 lines of fairly straightforward Swift code. We&rsquo;ll focus solely on rendering a subset of HTML, leaving CSS and Javascript as exercises for the reader :). We&rsquo;ll take many shortcuts and liberties, but in the end you should have an app that can render unstyled, standard HTML pages. And you&rsquo;ll also have some tools for writing programming language parsers by hand, which you could use to write your own custom language.</p>

<p>The feature set of our browser is going to be small, but the goal is this: <strong>you should be able to render this very browser tutorial web page in the browser itself</strong>. Fun, right?</p>

<p>(by the way: I&rsquo;m looking for work, so if you&rsquo;re looking to hire someone to work on browsers, programming languages, dev tools, or Swift apps, I&rsquo;m your guy! <a href="mailto:i.jasonbrennan@gmail.com">Please reach out</a>, I&rsquo;d love to hear from you)</p>

<h2>The Architecture</h2>

<p>Before we dive in to code, let&rsquo;s look at the overall archicture of what we&rsquo;re building, to make the challenge ahead more managable. Since HTML is a programming language, we&rsquo;ll follow a similar architecture to that of most compilers / interpreters, which is a sort of pipeline, where each part of the pipeline takes input and spits something else out for the next component to work with. So what are our inputs and components?</p>

<ol>
<li>We start with the <strong>raw html</strong>, as a <code>String</code>. This either comes from the network or a local file, but it doesn&rsquo;t really matter.</li>
<li>We then digest the html string into an array of <strong>tokens</strong>, in a process known as <em>tokenizing</em> or <em>lexing</em>. This essentially chews up the raw string into common pieces that are easier to digest, such as punctuation characters (<code>&lt;, &gt;, &quot;, etc</code>), whitespaces (newlines, tabs, spaces), digits, or just regular letter characters.</li>
<li>The tokens are then passed to the <strong>Parsing Context</strong>, a class whose core purpose is letting other types <em>consume</em> tokens they recognize, while also keeping track of which tokens have already been consumed.</li>
<li>Next we have structs representing <strong>the data we&rsquo;re parsing</strong>, things like, the <code>Document</code>, a tree of <code>Node</code>s, which consist of <code>Tag</code>s and <code>Attribute</code>s. We&rsquo;ll write little parsers for each of these things, that will call into the <code>ParsingContext</code> to consume the tokens they need for their construction.</li>
<li>Finally, when parsing is complete, we have data we can then use to <strong>display our SwiftUI pages</strong> with. In a traditional programming language, this might be the point where you output compiled code into an executable or evaluate your data with an interpreter, but here our &ldquo;interpreter&rdquo; will simply display a UI.</li>
</ol>

<p>With that general archictecture in mind, let&rsquo;s fire up Xcode and get started.</p>

<h3>Quick Tips</h3>

<p>If you&rsquo;re coding along as you read this tutorial, I highly recommend typing out all the code yourself, instead of copying and pasting. In my experience, I find this forces you to slow down and work more deliberately, and I think it&rsquo;ll help you understand things better in the process. You can also find <a href="https://github.com/jbrennan/SmolHTML">the complete source code on Github</a>.</p>

<p>I&rsquo;d also recommend changing things as you move along. None of what I&rsquo;ve written is the definitive way to write this code, and you could probably put your own spin on it. Or better, extend it to do even more!</p>

<p>The code I&rsquo;ll be showing in this tutorial is more or less &ldquo;finished&rdquo; as is (we won&rsquo;t be building to much of it iteratively, because that would take up a whole book!), but please know my browser <em>was</em> built iteratively (you can check out the git history if you&rsquo;d like to see my stumbles as I went!). Some bits of code in the tutorial will depend upon code we haven&rsquo;t written yet, so please use your imagination if things don&rsquo;t compile at every stage.</p>

<p>Finally, I won&rsquo;t be providing any unit tests in the tutorial, but you may very well like to include some, especially if you decide to extend your browser after you&rsquo;re done. I find programming languages lend themselves very well to unit testing, as they have well defined inputs and outputs.</p>

<h2>Starting the project</h2>

<p>Create a new Xcode project using a SwiftUI template. I called my browser <code>Smol</code> because it&rsquo;s very tiny, but feel free to let your creativity shine here. I made my browser be a Mac app just for ease of playing around with, but you could make yours an iOS app if you wanted, everything will work more or less the same. </p>

<p>In your project settings Info tab, add key for &ldquo;App Transport Security Settings,&rdquo; and inside that add a key for &ldquo;Allow arbitrary loads,&rdquo; setting its value to Yes. This will let us load http and https content from anywhere on the internet and it&rsquo;s not enabled by default.</p>

<h2>Tokenizing</h2>

<p>Tokenizing is the process of breaking down our program from a <code>String</code> into an array of <code>Token</code> elements, by scanning through the program character by character to build up different tokens. We&rsquo;ll make 3 types: <code>Token</code>, <code>ScanningCursor</code>, and <code>Tokenizer</code>.</p>

<p><code>Token</code> will be a small data struct that combines a token <code>Kind</code> with the text that makes it up. You could also include other data like where in the program this token is located (which would be helpful in showing errors to someone writing html), but it&rsquo;s not strictly necessary here.</p>

<p>We define the type along with some initializers that&rsquo;ll help us as we&rsquo;re tokenizing.</p>

<pre><code>struct Token: Equatable, CustomDebugStringConvertible {

    enum Kind: Equatable {
        case text, openAngleBracket, closeAngleBracket, forwardSlash, equals, hyphen, singleQuote, doubleQuote, whitespace, bang
    }

    let kind: Kind
    let body: String

    init(kind: Kind, body: String) {
        self.kind = kind
        self.body = body
    }

    init?(symbol: Character) {
        switch symbol {
        case &quot;&lt;&quot;: self.init(kind: .openAngleBracket, body: &quot;&lt;&quot;)
        case &quot;&gt;&quot;: self.init(kind: .closeAngleBracket, body: &quot;&gt;&quot;)
        case &quot;/&quot;: self.init(kind: .forwardSlash, body: &quot;/&quot;)
        case &quot;=&quot;: self.init(kind: .equals, body: &quot;=&quot;)
        case &quot;-&quot;: self.init(kind: .hyphen, body: &quot;-&quot;)
        case &quot;&#39;&quot;: self.init(kind: .singleQuote, body: &quot;&#39;&quot;)
        case &quot;\&quot;&quot;: self.init(kind: .doubleQuote, body: &quot;\&quot;&quot;)
        case &quot;!&quot;: self.init(kind: .bang, body: &quot;!&quot;)
        default: return nil
        }
    }

    var debugDescription: String { body }
}
</code></pre>

<p>Next, the <code>ScanningCursor</code> class will help us keep track of what character we&rsquo;re looking at at any given moment. This could theoretically just be a part of <code>Tokenizer</code>, but I&rsquo;ve pulled it out into its own type for possible testability and to keep the tokenizer simple.</p>

<pre><code>class ScanningCursor {
    private let programText: String
    var currentIndex: String.Index

    var isNotAtEnd: Bool { currentIndex &lt; programText.endIndex }

    init(programText: String) {
        self.programText = programText
        self.currentIndex = programText.startIndex
    }

    @discardableResult
    func advance() -&gt; Character {
        guard isNotAtEnd else { fatalError() }

        let currentCharacter = currentCharacter()
        currentIndex = programText.index(after: currentIndex)

        return currentCharacter
    }

    func currentCharacter() -&gt; Character {
        programText[currentIndex]
    }

    func previousCharacter() -&gt; Character {
        programText[programText.index(before: currentIndex)]
    }
}
</code></pre>

<p>Finally, the <code>Tokenizer</code> itself:</p>

<pre><code>class Tokenizer {
    private let cursor: ScanningCursor
    var scannedTokens = [Token]()

    init(programText: String) {
        cursor = ScanningCursor(programText: programText)
    }

    func scanAllTokens() -&gt; [Token] {
        while cursor.isNotAtEnd {
            scanNextToken()
        }

        return scannedTokens
    }

    private func scanNextToken() {
        let next = cursor.advance()

        if let token = Token(symbol: next) {
            return scannedTokens.append(token)
        } else if next.isWhitespace {
            return scannedTokens.append(Token(kind: .whitespace, body: String(next)))
        } else {
            scanText()
        }
    }

    private func scanText() {
        var body = String(cursor.previousCharacter())
        while cursor.isNotAtEnd {
            let next = cursor.currentCharacter()
            if Token(symbol: next) != nil {
                break
            }
            if next.isWhitespace { break }

            body.append(next)
            cursor.advance()
        }
        scannedTokens.append(Token(kind: .text, body: body))
    }
}
</code></pre>

<p>The tokenizer&rsquo;s primary public function runs a loop, attempting to parse tokens until the cursor says we&rsquo;ve reached the end of the program string.</p>

<p>The <code>scanNextToken()</code> method tells the cursor to pop off its next character and advance its internal position. With that <code>next</code> character, it then tries to decide what kind of token to make:</p>

<ul>
<li>if the character matches one of the punctuation token types, we append that token to our list and return</li>
<li>if the character is whitespace, we add a single whitespace token</li>
<li>otherwise, we assume the token will be any other text, so we start scanning that.</li>
</ul>

<p><code>scanText()</code> grabs the most recently popped-off character and starts its own loop, accumulating text characters into a single string. Here we&rsquo;re considering &ldquo;text&rdquo; to be &ldquo;anything that&rsquo;s neither whitespace nor one of our recognized punctuation tokens.&rdquo; This is a kind of strange way to tokenize text, but html is a strange kind of programming language! and we break things up this way to make parsing easier for us later on.</p>

<h2>The Parsing Context</h2>

<p>As mentioned earlier, the <strong>Parsing Context</strong>, is a class whose core purpose is letting other types <em>consume</em> tokens they recognize, while also keeping track of which tokens have already been consumed. It&rsquo;s similar to the scanning cursor from earlier, but a little more tailored moving forward (and at times, backward) through a list of tokens.</p>

<p>You can think of this type as similar to a graphics context, like an OpenGL or Core Graphics context. A graphics context is kind of like a canvas, where you call drawing methods on it (stroke this path, fill this rectangle) or set properties (the current font, the current transform matrix, etc). These calls manipulate the internal state of the context, until you&rsquo;re ready for it to spit out a final rendered image.</p>

<p>The parsing context is kind of like that, but instead of <em>adding to an eventual image</em>, we&rsquo;re subtracting bits of the internal token state while we parse out types. When we&rsquo;re all done parsing, the context should ideally be at the end of its list of tokens and we should have all our parsed data.</p>

<pre><code>class ParsingContext {

    private let tokens: [Token]
    private var tokenIndexStack = [0]
    private var currentTokenIndex: Int {
        get { tokenIndexStack.last! }
        set { tokenIndexStack[tokenIndexStack.endIndex - 1] = newValue }
    }

    var isNotAtEnd: Bool {
        currentTokenIndex &lt; tokens.count
    }

    // These might be whitespace tokens.
    var currentToken: Token { isNotAtEnd == false ? tokens.last! : tokens[currentTokenIndex] }
    var nextToken: Token { tokens[currentTokenIndex + 1] }
    var nextNextToken: Token { tokens[currentTokenIndex + 2] }
    var previousToken: Token { tokens[currentTokenIndex - 1] }

    init(tokens: [Token]) {
        self.tokens = tokens
    }

    enum ParseError: Error {
        case unexpectedToken(Token, feedback: String)
        case failedToParse
    }
</code></pre>

<p>We start with some properties around accessing the tokens. We store a list of all tokens and access them by an index, which is our current parsing location. Instead of storing a single index, we instead have a stack of indexes, with the <em>current</em> index being the top of this index stack. We&rsquo;ll look into this more below, but it allows us to move forward <em>and backward</em> through the list of tokens as we&rsquo;re parsing.</p>

<pre><code>    private func advance(when predicate: (Token) -&gt; Bool, skipWhitespaceTokens: Bool = true) -&gt; Bool {

        var skippedWhitespaceCount = 0
        if skipWhitespaceTokens {
            while isNotAtEnd &amp;&amp; currentToken.kind == .whitespace {
                currentTokenIndex += 1
                skippedWhitespaceCount += 1
            }
        }

        guard isNotAtEnd else { return false }

        if predicate(tokens[currentTokenIndex]) {
            currentTokenIndex += 1
            return true
        } else {
            currentTokenIndex -= skippedWhitespaceCount
            return false
        }
    }

    @discardableResult
    func consume(tokenKind kind: Token.Kind, feedback: String) throws -&gt; Token {
        try consume(where: { $0.kind == kind }, feedback: feedback)
    }

    @discardableResult
    func consume(where predicate: (Token) -&gt; Bool, skipWhitespaceTokens: Bool = true, feedback: String) throws -&gt; Token {
        let oldCurrentToken = self.currentToken
        guard advance(when: predicate, skipWhitespaceTokens: skipWhitespaceTokens) else {
            throw ParseError.unexpectedToken(oldCurrentToken, feedback: feedback)
        }
        return previousToken
    }
</code></pre>

<p>Next, we have the primary methods used for updating the token state, by advancing the cursor when we finding (<code>advance(when:...)</code>) and consuming matching tokens. The <code>advance()</code> method more or less just checks to see if the given <code>predicate</code> closure matches the current token. Most of the time in programming languages, we ignore whitespace tokens, so this method does that by default, but it has a flag to not skip, since we&rsquo;ll need that later on for some of our parsing.</p>

<p>The <code>consume(...)</code> methods build upon <code>advance(...)</code>, but will <code>throw</code> an error if matching fails. From this point onward in the parser architecture, we use Swift errors as a means of control flow to indicate more or less that parsing a certain token or syntax node was unsucessful. This doesn&rsquo;t necessarily mean there is an error, only that we weren&rsquo;t able to interpret a specific part a certain way (it might mean it should be interpreted another way).</p>

<p>The consume method takes a feedback string to make parsing failures a little clearer, and to make bugs in the parser a little easier to track down.</p>

<pre><code>    // MARK: - Helpers

    /// Use this method when you want to accumulate results until parsing fails, but you want to keep what you&#39;ve found so far.
    func untilThrowOrEndOfTokensReached&lt;ConsumedType&gt;(perform: () throws -&gt; ConsumedType) -&gt; [ConsumedType] {

        var results = [ConsumedType]()

        do {
            while isNotAtEnd {
                results.append(try perform())
            }
        } catch {
            return results
        }
        return results
    }

    func attempt&lt;ContentType&gt;(action: () throws -&gt; ContentType) throws -&gt; ContentType {
        tokenIndexStack.append(currentTokenIndex)
        var shouldRevertIndexStack = true

        defer {
            // Pop the stack if `try action()` fails.
            // doing it this way, instead of catching + rethrowing
            // so that the error chain continues to the original error, not our rethrow
            if shouldRevertIndexStack {
                _ = tokenIndexStack.popLast()
            }
        }

        let result = try action()

        // we succeeded, so pop the token index stack, and use THAT value as the new current index
        currentTokenIndex = tokenIndexStack.popLast()!
        shouldRevertIndexStack = false
        return result
    }

    func choose&lt;ContentType&gt;(from choices: [() throws -&gt; ContentType]) throws -&gt; ContentType {
        try attempt(action: {
            var mostRecentError: Error = ParseError.failedToParse

            for choice in choices {

                do {
                    return try attempt(action: {
                        try choice()
                    })
                } catch {
                    mostRecentError = error
                }
            }

            throw mostRecentError
        })
    }

    @discardableResult
    func consumeBetween&lt;ContentType&gt;(leftToken: Token.Kind, rightToken: Token.Kind, content: () throws -&gt; ContentType) throws -&gt; ContentType {
        try consume(tokenKind: leftToken, feedback: &quot;Expected a \(leftToken)&quot;)
        let consumedContent = try content()
        try consume(tokenKind: rightToken, feedback: &quot;Expected a \(rightToken)&quot;)

        return consumedContent
    }
}
</code></pre>

<p>Finally, we have 4 helper methods that we&rsquo;ll use while parsing.</p>

<p><code>untilThrowOrEndOfTokensReached(perform:)</code> calls its <code>perform</code> closure in a loop, accumulating values returned from it in an array, which it eventually returns either when the end of tokens is reached or (more likely) when the closure throws an error. In practice, we&rsquo;ll be calling other methods of the parsing context inside that closure while parsing syntax nodes. The point of this method is to essentially say &ldquo;after a while, parsing failed, so I&rsquo;m gonna give you what I&rsquo;ve successfully parsed until that point.&rdquo;</p>

<p><code>attempt(action:)</code> is extremely useful, as it allows us to try multiple parsing actions in the hopes they succeed (and thus, move the token cursor forward), but if the action <code>throws</code>, we&rsquo;re able to revert back to the previous cursor position. If we didn&rsquo;t use <code>attempt(action:)</code> when parsing and e.g., called <code>consume()</code> twice successfully, and then a third time unsucessfully, we would have failed to parse a whole thing, but we would have also moved the cursor along with us, now in a spot unable to try finding something else. <code>attempt(:)</code> solves this for us, and is why we use a stack of token indexes instead of just a single index (this also works recursively).</p>

<p><code>choose(from:)</code> takes an array of closures with parsing calls in them, each returning a value. It then runs through the array, calling each closure in order. If a closure successfully returns a value, <code>choose</code> will return that value. If a closure <code>throws</code>, then we move on to the next closure to try that. All of this is wrapped in an <code>attempt(action:)</code> call so that if parsing in one closure fails, the next one gets a fresh start before it parses. This method is useful when parsing could result in multiple possibilities in the same place in the program, and you frequently (but not always) would want your return type to be an <code>enum</code> with a choice for each of its cases.</p>

<p>Finally, <code>consumeBetween(leftToken:, rightToken:, content:)</code> helps us in the case when things are wrapped in certain tokens, for example quotes, parentheses, or angle brackets. It tries to consume the left token, then tries the <code>content</code> closure, and finally tries to consume the right token. If all of that succeeded, it returns whatever was returned by the closure.</p>

<p>And that completes the <code>ParsingContext</code>, which models common operations used throughout the HTML parsing process (and which could easily be reused with parsers for your own programming language too).</p>

<h2>Parsing HTML</h2>

<p>Now that we&rsquo;ve built ourselves parsing tools, lets use them to parse out HTML into our own data types (in programming language theory, these are known as &ldquo;abstract syntax trees / nodes,&rdquo; which is a fancy way of saying a set of types that are usually arranged in some sort of hierarchy or graph). We&rsquo;ll only make use of a few types, as most of HTML is fairly generic and has a similar structure all the way down.</p>

<p>To identify these syntax tree nodes, let&rsquo;s make a protocol for anything that is <code>Parsable</code>:</p>

<pre><code>protocol Parsable {
    static func parse(context: ParsingContext) throws -&gt; Self
}
</code></pre>

<p>Types that conform to this protocol will have to implement the above static method and return a parsed version of themselves, or throw an error if they couldn&rsquo;t be parsed out of the given <code>ParsingContext</code>. You could alternatively make this an initializer method instead, but that will shadow the auto-generated <code>struct</code> initializers, which is kind of annoying.</p>

<h3>Document</h3>

<p>Let&rsquo;s start at the top, with the <code>Document</code>. An HTML document is our model that more or less lines up with the html &ldquo;file&rdquo; as a whole. We&rsquo;ll keep ours very simple:</p>

<pre><code>struct Document: Hashable, Parsable {

    enum DocumentError: Error {
        case unableToFindHTMLNode
    }

    let htmlNode: Node

    static func parse(context: ParsingContext) throws -&gt; Document {
        let nodes = context.untilThrowOrEndOfTokensReached {
            try Node.parse(context: context, options: nil)
        }

        guard let htmlNode = nodes.first(where: { $0.element.lowercased() == &quot;html&quot; }) else {
            throw DocumentError.unableToFindHTMLNode
        }

        return Document(htmlNode: htmlNode)
    }
}
</code></pre>

<p>An html document has 0 or more &ldquo;nodes&rdquo; (tags) at the top level. It might have a <code>&lt;!doctype&gt;</code> tag, and it ideally should have an <code>&lt;html&gt;</code> tag too. Our <code>Document.parse(:)</code> implementation asks the given parsing context to parse out <code>Node</code>s until an error is thrown or we&rsquo;ve reached the end of the tokens. Then, we search through that array of nodes, looking for the <code>html</code> node, and finally, we return the document initialized with that found node (and we ignore any doctype or other nodes we might find). If we can&rsquo;t find any html node, we throw an error indicating such. It might be that the program really didn&rsquo;t contain an html tag, or more likely, that our <code>Node</code> parser failed to handle something inside the html node and errored out.</p>

<p>Our parser system is going to be kind of strict in what it accepts, which is contrary to how the Big Browsers tend to work, where they&rsquo;ll accept pretty much anything you throw at them. Our approach favours simplicity of implementation to get concepts across, at the cost of compatibility with lots of websites. As you build out your browser, feel free to expand what your parser can handle :)</p>

<h3>Node</h3>

<p>Now it&rsquo;s time for the real meat and potatoes of our syntax tree, the <code>Node</code>, which represents a &ldquo;node&rdquo; in the html document. It&rsquo;s more or less the data model equivalent of a <code>&lt;tag&gt;</code>, any attributes inside of the tag itself, and any children nested between the tags (the distinction between a node, an element, and a tag is subtle, and you may be used to using the terms interchangeably, but I&rsquo;ll try to keep them separate as best I can).</p>

<p>Let&rsquo;s start the <code>Node</code> type with some internal types and properties:</p>

<pre><code>struct Node: Hashable, Parsable {

    struct InternalElement {
        static let textRun = &quot;__textRun&quot;
        static let comment = &quot;__comment&quot;
    }

    enum Content: Hashable {
        case text(String)
        case childNodes([Node])
        case voidNode
    }

    enum NodeParseError: Error {
        case closingTagDidNotMatchOpeningTag(opening: String, closing: String)
        case openingTagWasActuallyClosing(tagName: String)
        case closingTagWasActuallyOpening(tagName: String)
        case didNotFindAnyText
    }

    let element: String
    let content: Content
    let attributes: [Attribute]
</code></pre>

<p><code>InternalElement</code> lists some private element names we&rsquo;ll use for bits of the html file that don&rsquo;t fall under normal html tag rules (we&rsquo;ll see more of them later).</p>

<p>Then we have the <code>Content</code> enum, which models the stuff inside of our node. This says, a node can either contain text, child nodes, or be a &ldquo;void&rdquo; node (that is, a node that only has a start tag, no end tag and no children. <code>&lt;img&gt;</code> is an example of a void node).</p>

<p>Next, we have an error type defined to list the things that can go wrong during parsing and which act as control flow.</p>

<p>Finally, we have <code>Node</code>&lsquo;s properties: its element (or tag name), the aforementioned content, and any attributes that were in the start tag.</p>

<p>Now it&rsquo;s on to parsing the node itself, which we&rsquo;ll break down into some chunks:</p>

<pre><code>static func parse(context: ParsingContext) throws -&gt; Node {
    let startTag = try Tag.parse(context: context)

    guard startTag.isEnd == false else {
        throw NodeParseError.openingTagWasActuallyClosing(tagName: startTag.element)
    }

    if startTag.element.lowercased() == &quot;doctype&quot; {
        return Node(element: &quot;doctype&quot;, content: .voidNode, attributes: startTag.attributes)
    }

    if startTag.isVoidElement {
        return Node(element: startTag.element, content: .voidNode, attributes: startTag.attributes)
    }
</code></pre>

<p>We begin by trying to parse a start tag (which we&rsquo;ll get to in a bit). Then, we check some conditions to see if we can bail early:</p>

<ul>
<li>If the tag that got parsed was an end tag (eg <code>&lt;/something&gt;</code>), then we throw an error. Alternatively, we could break <code>Tag</code> into 2 types, <code>StartTag</code> and <code>EndTag</code>, and let start tags fail to parse end tags.</li>
<li>Then we check to see if our start tag is a <code>doctype</code> tag, in which case we return immediately.</li>
<li>Finally, we check to see if the start tag represents a void element, and if so we also return immediately.</li>
</ul>

<p>If none of those conditions are met, we keep parsing. At this point, we have a start tag and we need to look for 0 or more children we might have, before reaching an end tag.</p>

<p>To parse child nodes, we&rsquo;re going to ask the context to parse nodes  until we hit an error. This way, we&rsquo;ll get 0 or more child nodes. Inside that loop, we&rsquo;re going to ask the context to choose from a few possibilities:</p>

<pre><code>    let children = context.untilThrowOrEndOfTokensReached(perform: {
        try context.choose(from: [
            { try Node.parse(context: context) },
</code></pre>

<p>The child might be a normal <code>Node</code> of some kind, so we recursively call <code>Node.parse()</code>.</p>

<pre><code>{
    let textContents = context.untilThrowOrEndOfTokensReached {
        try context.consume(where: { $0.kind != .openAngleBracket }, skipWhitespaceTokens: false, feedback: &quot;Expected a non `&lt;` token&quot;)
    }
    guard textContents.isEmpty == false else {
        throw NodeParseError.didNotFindAnyText
    }

    let contentRun = textContents
            .map(\.body)
            .joined()
            .replacingOccurrences(of: &quot;&amp;#x000A;&quot;, with: &quot;&quot;)
            .replacingOccurrences(of: &quot;\n&quot;, with: &quot; &quot;)
            .replacingOccurrences(of: &quot;\t&quot;, with: &quot; &quot;)
            .replacingOccurrences(of: &quot;&amp;lt;&quot;, with: &quot;&lt;&quot;)
            .replacingOccurrences(of: &quot;&amp;gt;&quot;, with: &quot;&gt;&quot;)
            .replacingOccurrences(of: &quot;&amp;quot;&quot;, with: &quot;\&quot;&quot;)
            .replacingOccurrences(of: &quot;&amp;amp;&quot;, with: &quot;&amp;&quot;)

    return Node(element: InternalElement.textRun, content: .text(contentRun), attributes: [])
},
</code></pre>

<p>If it&rsquo;s not a standard node, it might be a <strong>text run</strong> node. Text runs in html are not real nodes like <code>&lt;div&gt;</code> or <code>&lt;p&gt;</code>, instead they&rsquo;re the any text content inside of other tags. So if we have a node like <code>&lt;p&gt;Hi there&lt;/p&gt;</code>, this will get parsed out to a p <code>Node</code>, whose <code>content</code> is <code>.childNodes(children)</code>, and <code>children</code> will be an array with a single <code>Node</code>, whose <code>content</code> is <code>.text(&quot;Hi there&quot;)</code>. This structure <em>feels weird</em>, but it allows us to parse more complicated nodes like <code>&lt;p&gt;Hi there, &lt;bold&gt;friend&lt;/bold&gt;&lt;/p&gt;</code>. In short, we&rsquo;re wrapping otherwise un-tagged text into a pretend <code>&lt;text-run&gt;</code> tag and then treating it as we do other nodes.</p>

<p>To parse a text run, we first consume every token that&rsquo;s not an <code>&lt;</code> character, which we assume might be the beginning of a tag. If we find any contents, we then join the contents&rsquo; body together into one big string.</p>

<p>Then, we do some quick and dirty text replacement, replacing encoded html entities with their display characters and non-space whitespaces with spaces for display (this doesn&rsquo;t follow the html standard for whitespaces perfectly, but it works well enough). With all the replacement done, we return the text run node.   </p>

<pre><code>{
    try context.consumeBetween(leftToken: .openAngleBracket, rightToken: .closeAngleBracket) {
            try context.consume(tokenKind: .bang, feedback: &quot;Expected comment to begin with a bang&quot;)
            try context.consume(tokenKind: .hyphen, feedback: &quot;Expected comment to have a hyphen after the bang&quot;)
            try context.consume(tokenKind: .hyphen, feedback: &quot;Expected comment to have two hyphens after the bang&quot;)

            var done = false
            while done == false {

                if context.currentToken.kind == .hyphen &amp;&amp; context.nextToken.kind == .hyphen &amp;&amp; context.nextNextToken.kind == .closeAngleBracket {

                    try context.consume(tokenKind: .hyphen, feedback: &quot;-&quot;)
                    try context.consume(tokenKind: .hyphen, feedback: &quot;-&quot;)
                    done = true
                } else {
                    try context.consume(where: { _ in true }, skipWhitespaceTokens: false, feedback: &quot;consuming comment contents&quot;)
                }
            }

            return Node(element: InternalElement.comment, content: .voidNode, attributes: [])
        }
}])})
</code></pre>

<p>Finally, if the child node wasn&rsquo;t a normal node, nor a text run node, we see if it was perhaps a comment node, which takes the form <code>&lt;!-- your comment here --&gt;</code>. Looking inside angle brackets, we first attempt to consume a bang, then 2 hyphen tokens. After that, we loop, peeking at the next 3 tokens looking for the ending <code>--&gt;</code> pattern. If we don&rsquo;t find that pattern, we just consume and ignore whatever content was there. Once we&rsquo;re done munching tokens, we return the internal comment node.</p>

<pre><code>        .filter {
            if $0.element == InternalElement.comment { return false }
            if $0.element != InternalElement.textRun { return true }

            // filter out empty text run nodes
            return $0.textContent?.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false
        }
</code></pre>

<p>As a very last step of parsing child nodes, we remove nodes that are comments or nodes that are text runs with empty text. Everything else, we keep. And now we&rsquo;re done parsing child nodes.</p>

<pre><code>
    let endTag = try Tag.parse(context: context)
    guard endTag.isEnd else {
        throw NodeParseError.closingTagWasActuallyOpening(tagName: endTag.element)
    }

    guard startTag.element == endTag.element else {
        throw NodeParseError.closingTagDidNotMatchOpeningTag(opening: startTag.element, closing: endTag.element)
    }

    return .init(
        element: startTag.element,
        content: .childNodes(children),
        attributes: startTag.attributes
    )
}
</code></pre>

<p>After the child nodes are parsed, all that&rsquo;s left is to parse the end tag, make sure it&rsquo;s really an end tag, and ensure that it matches the start tag. If all of that succeeded, we return the fully constructed <code>Node</code>. Most of what we just did was bookkeeping (checking tags, make sure start / end tags match), and then parsing the node&rsquo;s children, if any.</p>

<h3>Tag</h3>

<p>We&rsquo;ve papered over <code>Tag</code> parsing, though, so let&rsquo;s look at that now:</p>

<pre><code>struct Tag: Parsable {

    let element: String
    let isEnd: Bool
    let attributes: [Attribute]

    var isVoidElement: Bool {
        [&quot;area&quot;, &quot;base&quot;, &quot;br&quot;, &quot;col&quot;, &quot;embed&quot;, &quot;hr&quot;, &quot;img&quot;, &quot;input&quot;, &quot;link&quot;, &quot;meta&quot;, &quot;source&quot;, &quot;track&quot;, &quot;wbr&quot;].contains(element)
    }
</code></pre>

<p>We start our <code>Tag</code> type with some properties, alluding to the <code>Attribute</code> type we&rsquo;ll see shortly as well. We also list the known void elements to determine if our element should be considered void. Now on to the parsing:</p>

<pre><code>    static func parse(context: ParsingContext, options: ParsingOptions?) throws -&gt; Tag {
        try context.consumeBetween(leftToken: .openAngleBracket, rightToken: .closeAngleBracket) {
            let slashToken = try? context.consume(tokenKind: .forwardSlash, feedback: &quot;Expected a `/`&quot;)
            let _ = try? context.consume(tokenKind: .bang, feedback: &quot;Expected a `!`&quot;)
</code></pre>

<p>A tag is wrapped in <code>&lt;</code> and <code>&gt;</code> angle brackets. Within those, we first look for an initial forward slash token, and if we find it we assume we&rsquo;re parsing an end tag (we use <code>try?</code> to optionally parse this â€” if we don&rsquo;t find the slash, we&rsquo;re not considering that an error worth bailing from). We also look for an optional bang token and just completely ignore it if we find it (this is for the <code>&lt;!doctype&gt;</code> tag).</p>

<pre><code>            let identifier = try context.consume(tokenKind: .text, feedback: &quot;Expected a tag name&quot;)

            let attributes = context.untilThrowOrEndOfTokensReached(perform: {
                try context.attempt(action: {
                    try Attribute.parse(context: context, options: options)
                })
            })
</code></pre>

<p>Next, we parse an identifier that we&rsquo;ll use for the tag&rsquo;s element. Then we attempt to parse as many attributes as we can (there may be 0).</p>

<pre><code>            // If there&#39;s a trailing slash (eg &lt;img /&gt;), consume it but ignore it. this is invalid html
            _ = try? context.consume(tokenKind: .forwardSlash, feedback: &quot;Expected a trailing `/`&quot;)
            return Tag(element: identifier.body, isEnd: slashToken != nil, attributes: attributes)
        }
    }
}
</code></pre>

<p>Finally, optionally look for and ignore a trailing slash at the end of the tag, as it&rsquo;s not actually valid html (this was news to me when I started working on the browser). However, it&rsquo;s extremely common, so I thought it warranted handling here to make more of the web work. With that out of the way, we return our completed tag.</p>

<h3>Attribute</h3>

<p>Ok, last part of the parser! the attributes inside a tag.</p>

<pre><code>struct Attribute: Hashable, Parsable {
    let key: String
    let value: String

    enum AttributeParseError: Error {
        case emptyAttributeValue(key: String)
    }

    static func parse(context: ParsingContext, options: ParsingOptions?) throws -&gt; Attribute {

        let key = try context.consume(tokenKind: .text, feedback: &quot;Expected an attribute name&quot;)

        guard let _ = try? context.consume(tokenKind: .equals, feedback: &quot;Expected an equals sign&quot;) else {
            return Attribute(key: key.body, value: key.body)
        }
</code></pre>

<p>Attributes are (usually) key-value pairs, so those are our properties (for attributes that don&rsquo;t have explicit values, we&rsquo;ll just repeat the key for the value). </p>

<p>Then, we start parsing. First we parse the key, then we look for an equals sign token. If we don&rsquo;t find it, we assume this attribute is the valueless kind and return it immediately. Otherwise, we parse the value, as a choice:</p>

<pre><code>let value = try context.choose(from: [
{
    try context.consumeBetween(leftToken: .doubleQuote, rightToken: .doubleQuote) {
        let textContents = context.untilThrowOrEndOfTokensReached {
            try context.consume(where: { $0.kind != .doubleQuote }, skipWhitespaceTokens: false, feedback: &quot;Expected a non quote token&quot;)
        }

        return textContents
            .map(\.body)
            .joined()
    }
},
</code></pre>

<p>First choice: the value is between double quotes, and we consume everything inside that isn&rsquo;t a double quote (and we don&rsquo;t skip whitespaces either). Then we join all those tokens together and return that as the value.</p>

<pre><code>{
    try context.consumeBetween(leftToken: .singleQuote, rightToken: .singleQuote) {
        let textContents = context.untilThrowOrEndOfTokensReached {
            try context.consume(where: { $0.kind != .singleQuote }, skipWhitespaceTokens: false, feedback: &quot;Expected a non single quote token&quot;)
        }

        return textContents
            .map(\.body)
            .joined()
    }
},
</code></pre>

<p>Second choice: same thing as before, except between single quotes.</p>

<pre><code>{
    let textContents = context.untilThrowOrEndOfTokensReached {
        try context.consume(
            where: {
                $0.kind != .singleQuote &amp;&amp; $0.kind != .doubleQuote &amp;&amp; $0.kind != .whitespace &amp;&amp; $0.kind != .closeAngleBracket
        },
            skipWhitespaceTokens: false,
            feedback: &quot;Expected non-whitespace, non-quote characters&quot;)
    }

    guard textContents.isEmpty == false else {
        throw AttributeParseError.emptyAttributeValue(key: key.body)
    }

    return textContents
        .map(\.body)
        .joined()
}
</code></pre>

<p>Final choice: we look for a value that&rsquo;s <em>not</em> wrapped in any kind of quotes. These kinds of values are delimitted by whitespace (or an angle bracket), so we consume basically everything else, make sure we actually found something non-empty, and join those tokens together into a value.</p>

<pre><code>        ])

        return Attribute(key: key.body, value: value)
    }
}
</code></pre>

<p>Last, we return the completed attribute.</p>

<h2>End of Part 1</h2>

<p>This completes the end of part 1! We built ourselves some tools for breaking apart a program string into tokens and parsing them. And then we built some data types that know how to parse themselves using those tools. HTML is a kind of strange language, but we saw some familiar patterns repeated in multiple places (things being wrapped inside others, for example).</p>

<p>In the next part, we&rsquo;ll take the data we just parsed and render it with SwiftUI. <a href="https://nearthespeedoflight.com/browser-2.html">Onward to part 2!</a></p>

<h1>Part 2: Rendering in SwiftUI</h1>

<p>Welcome to part 2 of &ldquo;Writing a web browser engine in Swift!&rdquo; In <a href="https://nearthespeedoflight.com/browser.html">part 1</a>, we built a basic html parser from the ground up, learning about tokenizing, parsing, and syntax trees. We now have a fairly complete set of tools that can parse html into plain old Swift structs.</p>

<p>In this part, we&rsquo;ll build our rendering engine with SwiftUI views. Let&rsquo;s get started.</p>

<h2>The Architecture</h2>

<p>The architecture of our rendering engine should look pretty familiar to anyone who&rsquo;s worked with SwiftUI before: we&rsquo;re more or less just going to have views which render our node hierarchy. It&rsquo;s almost exclusively composed of standard SwiftUI views, plus a controller object for loading HTML pages, and a few extensions on the <code>Node</code> type to more easily work with its properties. Here are the main pieces we&rsquo;ll be working with.</p>

<ul>
<li><code>PageController</code> is responsible for loading web urls asynchronously and parsing them into <code>Document</code>s. It also maintains the back / forward stacks of documents.</li>
<li>Some views:

<ul>
<li><code>BrowserView</code> is the primary view, containing our chrome (back / forward / address bar) and the document view.</li>
<li><code>WebDocumentView</code> displays either a homepage, error page, or the contents of the loaded page, depending on the page controller&rsquo;s state.</li>
<li><code>BodyView</code> is the true beginnings of our rendering engine, it nests our page&rsquo;s content in a scroll view.</li>
<li><code>BlocksView</code> displays views for 0 or more nodes in a vertical stack. It picks a different view depending on the node&rsquo;s element.</li>
<li><code>InlineContentWrappingBlockView</code> combines the text of all its inline elements into one big <code>Text</code> for rendering.</li>
<li><code>ListNodeView</code> renders ordered or unordered lists and their items.</li>
<li><code>ImageView</code> asynchronously downloads and renders img nodes.</li>
</ul></li>
<li>Extensions on <code>Node</code> for accessing its content.</li>
</ul>

<h3>The Page Controller</h3>

<p>The <code>PageController</code> is our main controller object, responsible for loading pages, parsing them, and managing the back / forward stacks:</p>

<pre><code>class PageController: ObservableObject {

    enum State {
        case notLoaded
        case loaded(Document, URL)
        case failed(Error)
    }

    private enum LoadingError: Error {
        case failedToLoad(URL)
    }

    @Published var state = State.notLoaded {
        didSet {
            if let currentlyLoadedDocument {
                address = currentlyLoadedDocument.1.absoluteString
            }
        }
    }
    var address = &quot;https://nearthespeedoflight.com/smol.html&quot;

    private var backStack: [(Document, URL)] = []
    private var forwardStack: [(Document, URL)] = []

    var canGoBack: Bool { backStack.isEmpty == false }
    var canGoForward: Bool { forwardStack.isEmpty == false }
</code></pre>

<p>First we set up some nested types. The controller can be in one of three <code>State</code>s: an initial unloaded state (maybe you show a homepage?), a loaded state with the parsed document and the URL it came from, and the failed error state.</p>

<p>Then we have some properties, mainly the controller&rsquo;s current <code>state</code>, its current <code>address</code> string, and the back / forward stacks.</p>

<pre><code>    func loadPage(at url: URL) {
        Task {
            let newState: State
            do {
                let (data, response) = try await URLSession.shared.data(from: url)

                if let currentlyLoadedDocument {
                    backStack.append(currentlyLoadedDocument)
                    forwardStack = []
                }

                let htmlString = String(data: data, encoding: .utf8) ?? &quot;&quot;
                let tokenizer = Tokenizer(programText: htmlString)
                let context = try ParsingContext(tokens: tokenizer.scanAllTokens())

                newState = .loaded(try Document.parse(context: context, options: nil), response.url ?? url)
            } catch {
                print(&quot;error loading page: \(error)&quot;)
                newState = .failed(error)
            }

            await MainActor.run {
                state = newState
            }
        }
    }
</code></pre>

<p>To load a page, we kick off an async <code>Task</code>, await the loading of the given url, then we put the data through our parser pipeline. We also set the back / forward stacks to account for the state change that&rsquo;s about to happen.</p>

<p>This is all made a little awkward due to error handling, as we want to catch any errors that happen here: there could be URL related errors, there could be an error in the parsing context, or there could be an error parsing the document. If there is an error, we want to record it. This wouldn&rsquo;t be so bad on its own, but we don&rsquo;t want to do any of this parsing on the main actor, where it could freeze the UI, <em>but</em> we must update our controller&rsquo;s <code>state</code> property on the main actor, as our view depends on that property to draw itself.</p>

<pre><code>    private var currentlyLoadedDocument: (Document, URL)? {
        switch state {
        case .notLoaded, .failed: return nil
        case let .loaded(document, url): return (document, url)
        }
    }

    func goBack() {
        guard let (previousDocument, previousURL) = backStack.popLast() else { return }
        if let currentlyLoadedDocument {
            forwardStack.append(currentlyLoadedDocument)
        }
        state = .loaded(previousDocument, previousURL)
    }

    func goForward() {
        guard let (nextDocument, nextURL) = forwardStack.popLast() else { return }
        if let currentlyLoadedDocument {
            backStack.append(currentlyLoadedDocument)
        }
        state = .loaded(nextDocument, nextURL)
    }
}
</code></pre>

<p>Finally, we have a helper property for accessing the currently loaded document, if any, and methods for going back and forward. That wraps up our controller. Next, we&rsquo;ll see how the views make use of it while displaying our nodes.</p>

<h3>The Browser View</h3>

<p>As mentioned above, our <code>BrowserView</code> is the primary view for our browser window: it composes the &ldquo;chrome&rdquo; of our UI, plus the actual rendered content in another view. Our UI is going to be very simple, but you could extend it to use tabs, or even something more imaginative if you want :)</p>

<pre><code>struct BrowserView: View {
    @ObservedObject var controller: PageController
    @FocusState private var addressIsFocused: Bool
</code></pre>

<p>All we need are 2 properties, an observed page controller and the focus state of the address textfield, so that focus works like you&rsquo;d expect as we navigate.</p>

<pre><code>    var body: some View {
        VStack(spacing: 0) {
            HStack {
                HStack(spacing: 0) {
                    Button(action: { controller.goBack() }) {
                        Image(systemName: &quot;arrowtriangle.left.fill&quot;)
                    }.disabled(controller.canGoBack == false)
                    Button(action: { controller.goForward() }) {
                        Image(systemName: &quot;arrowtriangle.right.fill&quot;)
                    }.disabled(controller.canGoForward == false)
                }
                TextField(&quot;Address&quot;, text: $controller.address)
                    .onSubmit {
                        addressIsFocused = false
                        guard let url = URL(string: controller.address) else { return }
                        controller.loadPage(at: fullURL(forURLToLoad: url))
                    }
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .focused($addressIsFocused)
            }
            .padding()
            Divider()
</code></pre>

<p>The body of our view until this point is all about the chrome. We create our back / forward buttons and the address bar, and we bind their actions to our controller.</p>

<pre><code>            WebDocumentView(controller: controller)
                .background(.white)
                .environment(\.openURL, .init(handler: { url in
                    controller.loadPage(at: fullURL(forURLToLoad: url))
                    addressIsFocused = false
                    return .handled
                }))
        }
</code></pre>

<p>We configure the WebDocumentView and override SwiftUI&rsquo;s <code>openURL</code> environment value. When the user clicks a link in our app, SwiftUI invokes this callback, giving our app a chance to handle the URL. With the given URL, we construct an absolute URL (below), adjust the text field&rsquo;s focus, and tell the system we handled the url (we could also tell the system to handle it instead if the URL was eg <code>mailto:...</code>, but I&rsquo;ll leave that to you). </p>

<pre><code>        .environment(\.urlBuilder, fullURL(forURLToLoad:))
    }

    private func fullURL(forURLToLoad urlToLoad: URL) -&gt; URL {
        if urlToLoad.host != nil { return urlToLoad }

        switch controller.state {
        case .failed, .notLoaded: return urlToLoad
        case .loaded(_, let loadedURL):
            return URL(string: urlToLoad.path, relativeTo: loadedURL.deletingLastPathComponent()) ?? urlToLoad
        }
    }
} // End of BrowserView

private struct URLBuilderKey: EnvironmentKey {
    static let defaultValue: (URL) -&gt; URL = { $0 }
}

extension EnvironmentValues {
    /// A function that takes a (potentially &quot;relative&quot;) web url to load, and fleshes it out to a full url that includes a host.
    var urlBuilder: (URL) -&gt; URL {
        get { self[URLBuilderKey.self] }
        set { self[URLBuilderKey.self] = newValue }
    }
}
</code></pre>

<p>Finally, we use the environment modifier for a custom environment value. The <code>urlBuilder</code> is a closure / function responsible for taking a URL (one that&rsquo;s possibly relative, eg just <code>/page.html</code> vs <code>https://example.com/page.html</code>) and expanding it to an absolute URL so that pages and assets like images can be loaded.</p>

<p>We do this as an environment value so that other views in the hierarchy can access the functionality.</p>

<h3>Web Document View</h3>

<p>The <code>WebDocumentView</code> takes up the majority of space in our browser window. What it shows depends on the <code>state</code> of the page controller, either showing a simple home page, error screen, or the loaded content.</p>

<pre><code>struct WebDocumentView: View {
    @ObservedObject var controller: PageController

    var body: some View {
        switch controller.state {
        case .notLoaded:
            Text(&quot;Let&#39;s load a web page!&quot;)
                .frame(maxWidth: .infinity, maxHeight: .infinity)
        case .failed(let error):
            Text(verbatim: &quot;Failed to load page. Error: \(error)&quot;)
                .frame(maxWidth: .infinity, maxHeight: .infinity)
        case .loaded(let document, _):
            BodyView(bodyNode: document.htmlNode.firstDirectChild(named: &quot;body&quot;)!)
                .navigationTitle(
                    document
                        .htmlNode
                        .firstDirectChild(named: &quot;head&quot;)?
                        .firstDirectChild(named: &quot;title&quot;)?
                        .firstDirectChild(named: Node.InternalElement.textRun)?
                        .textContent ?? &quot;Smol&quot;
                )
                .environment(\.font, Font.custom(&quot;Times&quot;, size: 16))
        }
    }
}
</code></pre>

<p>The <code>BodyView</code> accesses some properties on <code>Node</code> which we&rsquo;ll write shortly for accessing child nodes more easily. We drill down to find the page&rsquo;s title, if it has one, and set that as our window title. Finally, we set a default font on the document&rsquo;s text. &ldquo;Times&rdquo; is the font you see in most browsers with unstylized text (but you&rsquo;re allowed to choose any font you&rsquo;d like here).</p>

<h3>Node extensions</h3>

<p>Before we go any further with our views, let&rsquo;s write those helpers in an extension on <code>Node</code>.</p>

<pre><code>extension Node {
    var childNodes: [Node] {
        switch content {
        case .voidNode, .text: return []
        case .childNodes(let nodes): return nodes
        }
    }

    var textContent: String? {
        switch content {
        case .childNodes, .voidNode: return nil
        case .text(let text): return text
        }
    }

    func firstDirectChild(named element: String) -&gt; Node? {
        childNodes.first(where: { $0.element == element })
    }
</code></pre>

<p>These properties help us access child nodes and text content more easily.</p>

<pre><code>    var childNodesSortedIntoBlocks: [Node] {
        var nodesToReturn = [Node]()
        var inlineElements = [Node]()

        func addInlineElementsAsGroupIfNeeded() {
            guard inlineElements.isEmpty == false else { return }
            // make a fake block element that has all these as children
            let wrapper = Node(element: &quot;p&quot;, content: .childNodes(inlineElements), attributes: [])
            // and append it to our list to return
            nodesToReturn.append(wrapper)
            // then, empty the inlineElements list
            inlineElements = []
        }

        for node in childNodes {
            if isInlineNode {
                inlineElements.append(node)
            } else {
                addInlineElementsAsGroupIfNeeded()
                nodesToReturn.append(node)
            }
        }
        addInlineElementsAsGroupIfNeeded()
        return nodesToReturn
    }

    var isInlineNode: Bool {
        [InternalElement.textRun, &quot;a&quot;, &quot;abbr&quot;, &quot;acronym&quot;, &quot;audio&quot;, &quot;b&quot;, &quot;bdi&quot;, &quot;bdo&quot;, &quot;big&quot;, &quot;br&quot;, &quot;button&quot;, &quot;canvas&quot;, &quot;cite&quot;, &quot;code&quot;, &quot;data&quot;, &quot;datalist&quot;, &quot;del&quot;, &quot;dfn&quot;, &quot;em&quot;, &quot;embed&quot;, &quot;i&quot;, &quot;iframe&quot;, &quot;img&quot;, &quot;input&quot;, &quot;ins&quot;, &quot;kbd&quot;, &quot;label&quot;, &quot;map&quot;, &quot;mark&quot;, &quot;meter&quot;, &quot;noscript&quot;, &quot;object&quot;, &quot;output&quot;, &quot;picture&quot;, &quot;progress&quot;, &quot;q&quot;, &quot;ruby&quot;, &quot;s&quot;, &quot;samp&quot;, &quot;script&quot;, &quot;select&quot;, &quot;slot&quot;, &quot;small&quot;, &quot;span&quot;, &quot;strong&quot;, &quot;sub&quot;, &quot;sup&quot;, &quot;svg&quot;, &quot;template&quot;, &quot;textarea&quot;, &quot;time&quot;, &quot;u&quot;, &quot;tt&quot;, &quot;var&quot;, &quot;video&quot;, &quot;wbr&quot;].contains(element)
    }
</code></pre>

<p>This next property is a little more involved. When we&rsquo;re rendering nodes, we want block nodes, like <code>&lt;p&gt;</code>, <code>&lt;div&gt;</code>, etc. to flow one after another, vertically down the page, while things like <code>&lt;bold&gt;</code>, <code>&lt;a&gt;</code>, etc. flow within the same line like words in a paragraph.</p>

<p>The trouble for us is, in html those inline elements don&rsquo;t have exist inside of block elements at all, they can exist outside of them too. For example:</p>

<pre><code>&lt;body&gt;
    &lt;bold&gt;Some bold text&lt;/bold&gt;
    &lt;p&gt;A paragraph&lt;/p&gt;
&lt;/body&gt;
</code></pre>

<p>The bold text is just kinda hanging out as inline, but inline relative <em>to what?</em> I&rsquo;m not entirely sure how other browsers solve this, but we&rsquo;ve solved it by grouping any inline elements as children of a fake, inserted <code>&lt;p&gt;</code> node.</p>

<pre><code>    var attributeDictionary: [String: String] {
        Dictionary(uniqueKeysWithValues: attributes.map({ ($0.key, $0.value) }))
    }
}
</code></pre>

<p>Lastly, we offer a way to access the node&rsquo;s attributes as a dictionary.</p>

<p>Now we have enough tools at our disposal to write the rest of the views.</p>

<h3>The BodyView</h3>

<p>This view hosts our browser&rsquo;s scroll view, which then displays child nodes in another view.</p>

<pre><code>struct BodyView: View {
    let bodyNode: Node
    var body: some View {
        ScrollView {
            BlocksView(children: bodyNode.childNodesSortedIntoBlocks)
            .padding(20)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .topLeading)
        .background(Color.white)
    }
}
</code></pre>

<p>The hierarchy here is mostly straightforward: the <code>BlocksView</code> is initialized with the child nodes of the body and is given a global padding. Then we extend the frame of the scroll view to stretch as much as possible and align the content to the top leading edge, like other browsers do.</p>

<h3>BlocksView</h3>

<p>This one is kind of fun: it&rsquo;s a reusable view that vertically stacks the child nodes it was given, rendering them with the appropriate view depending on what element they are. It even recursively uses itself in a few cases.</p>

<pre><code>struct BlocksView: View {
    let children: [Node]

    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            ForEach(children, id: \.self) { childNode in
                switch childNode.element {
                case &quot;h1&quot;:
                    InlineContentWrappingBlockView(node: childNode)
                        .font(Font.custom(&quot;Times&quot;, size: 32).bold())
                case &quot;h2&quot;:
                    InlineContentWrappingBlockView(node: childNode)
                        .font(Font.custom(&quot;Times&quot;, size: 28).bold())
                case &quot;h3&quot;:
                    InlineContentWrappingBlockView(node: childNode)
                        .font(Font.custom(&quot;Times&quot;, size: 24).bold())
                case &quot;p&quot;:
                    InlineContentWrappingBlockView(node: childNode)
                case &quot;div&quot;, &quot;section&quot;, &quot;main&quot;, &quot;footer&quot;, &quot;article&quot;, &quot;header&quot;, &quot;nav&quot;, &quot;aside&quot;:
                    BlocksView(children: childNode.childNodesSortedIntoBlocks)
                case &quot;pre&quot;:
                    BlocksView(children: childNode.childNodesSortedIntoBlocks)
                        .font(Font.system(size: 13, design: .monospaced))
                case &quot;blockquote&quot;:
                    BlocksView(children: childNode.childNodesSortedIntoBlocks)
                        .padding(.leading, 20)
                case &quot;ul&quot;: ListNodeView(node: childNode, style: .unordered)
                case &quot;ol&quot;: ListNodeView(node: childNode, style: .ordered)
                case &quot;hr&quot;: Divider()
                case &quot;script&quot;: EmptyView()
                case &quot;br&quot;: Color.clear.padding(20)
                default: Text(&quot;unknown block element: &lt;\(childNode.element)&gt;&quot;)
                }
            }
        }
    }
}
</code></pre>

<p>We don&rsquo;t support special rendering for every element under the sun, so if we find an element we don&rsquo;t know about, we just render that we found an unknown block. You could default it to behaving like a <code>&lt;div&gt;</code> if you wanted, but I like calling them out like this instead because I&rsquo;m more motivated to give it a proper view that way.</p>

<h3>Inline nodes</h3>

<p>Inline nodes are interesting, because to render them we can&rsquo;t just use views placed in some kind of stack. Instead, we want them to be rendered one after another like text, wrapping to the next line as needed. And indeed, that&rsquo;s how we&rsquo;re going to do it in SwiftUI, by combining (or in Swift terms, using <code>reduce()</code>) inline contents into an <code>AttributedString</code> and rendering it in a single <code>Text</code> view per inline &ldquo;block.&rdquo;</p>

<pre><code>struct InlineContentWrappingBlockView: View {
    let node: Node
    @Environment(\.font) var font

    var body: some View {
        Text(
            node
                .childNodes
                .map { $0.attributedText(defaultFont: font ?? Font.custom(&quot;Times&quot;, size: 16)) }
                .reduce(AttributedString(), +)
        )
        .lineSpacing(4)
        .fixedSize(horizontal: false, vertical: true)
    }
}
</code></pre>

<p>In the body of our body, we return a single <code>Text</code>, initialized with an attributed string. The attributed string is created by mapping the node&rsquo;s child nodes and calling the <code>attributedText(defaultFont:)</code> method on each (we&rsquo;ll see that property in a moment). This mapping gives us an array of attribute strings, so we <code>reduce()</code> them into a single attributed string.</p>

<pre><code>extension Node {
    func attributedText(defaultFont: Font) -&gt; AttributedString {
        switch element {
        case InternalElement.textRun:
            var attributes = AttributeContainer()
            attributes.font = defaultFont

            return AttributedString(textContent ?? &quot;&quot;, attributes: attributes)
</code></pre>

<p>To get the attributed text for a node, we switch over its <code>element</code> to see how we should format it. Here we have the base case: a text run. We create an attribute container, use the font that was passed in, and return an attributed string with the node&rsquo;s text content and those attributes.</p>

<pre><code>        case &quot;em&quot;, &quot;i&quot;:
            var attributes = AttributeContainer()
            attributes.font = defaultFont.italic()

            return childNodes
                .map { $0.attributedText(defaultFont: defaultFont.italic()) }
                .reduce(AttributedString(), +)
                .mergingAttributes(attributes, mergePolicy: .keepCurrent)
</code></pre>

<p>The rest of the cases are similar, in that we create some attributes, modifying the passed in font as needed. But in order to create the final attributed string, we actually need to recursively call ourselves so that we can handle multiple overlapping styles (eg a link node wrapped inside an italics node). </p>

<pre><code>        case &quot;strong&quot;, &quot;b&quot;:
            var attributes = AttributeContainer()
            attributes.font = defaultFont.bold()

            return childNodes
                .map { $0.attributedText(defaultFont: defaultFont.bold()) }
                .reduce(AttributedString(), +)
                .mergingAttributes(attributes, mergePolicy: .keepCurrent)
        case &quot;code&quot;:
            var attributes = AttributeContainer()
            let monospaced = Font.system(size: 13, design: .monospaced)
            attributes.font = monospaced

            return childNodes
                .map { $0.attributedText(defaultFont: monospaced) }
                .reduce(AttributedString(), +)
                .mergingAttributes(attributes, mergePolicy: .keepCurrent)
        case &quot;a&quot;:
            var attributes = AttributeContainer()
            attributes.link = URL(string: attributeDictionary[&quot;href&quot;] ?? &quot;&quot;)
            attributes.underlineStyle = .single

            return childNodes
                .map { $0.attributedText(defaultFont: defaultFont) }
                .reduce(AttributedString(), +)
                .mergingAttributes(attributes, mergePolicy: .keepCurrent)
        default:
            var attributes = AttributeContainer()
            attributes.font = defaultFont

            return childNodes
                .map { $0.attributedText(defaultFont: defaultFont) }
                .reduce(AttributedString(), +)
                .mergingAttributes(attributes, mergePolicy: .keepCurrent)
        }
    }
}
</code></pre>

<p>It&rsquo;s all a little boilerplatey but it gets the job done.</p>

<h3>ListNodeView</h3>

<p>Our last node view is the <code>ListNodeView</code>, which we&rsquo;ll use for displaying both ordered and unordered lists (<code>&lt;ol&gt;</code> and <code>&lt;ul&gt;</code>).</p>

<pre><code>struct ListNodeView: View {
    enum Style {
        case ordered, unordered

        func listMarker(for index: Int) -&gt; String {
            switch self {
            case .ordered: return &quot;\(index + 1).&quot;
            case .unordered: return &quot;â€¢&quot;
            }
        }
    }
</code></pre>

<p>We start with an enum for the two list styles, and a function for picking the right list item marker for the given index.</p>

<pre><code>    let node: Node
    let style: Style

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            ForEach(Array(zip(node.childNodes.indices, node.childNodes)), id: \.1) { (index, childNode) in
                HStack(alignment: .firstTextBaseline, spacing: 8) {
                    Text(verbatim: style.listMarker(for: index))
                    BlocksView(children: childNode.childNodesSortedIntoBlocks)
                }
            }
        }
    }
}
</code></pre>

<p>The body of the list node should look pretty straightforward at this point: a vertical stack wherein we iterate all our child nodes and render them as list items (using a kind of noisy <code>Array/zip</code> dance to get the index). A list item uses a horizontal stack to display the marker, followed by a <code>BlocksView</code> for the grouped children (it could be, for example, multiple paragraphs).</p>

<h3>Preserving Whitespace</h3>

<p>You may notice at this point, if you load up a webpage with a <code>&lt;pre&gt;</code> tag, it uses a monospaced font but it does not preserve whitespace. That&rsquo;s because we&rsquo;re currently discarding tabs and newlines in our parser. But for <code>&lt;pre&gt;</code> tags we should be preserving it in child nodes (and all of their descendents). So let&rsquo;s make some modifications to the parser.</p>

<p>In the parse method of <code>Node</code>, immediately before parsing child nodes, let&rsquo;s add the following line:</p>

<pre><code>let shouldPreserveWhiteSpace = startTag.element == &quot;pre&quot;
</code></pre>

<p>Then, in the 2nd choice closure (text runs), we want to replace whitespaces only when we&rsquo;re <em>not</em> preserving whitespace. Change our entity decoding code to the following:</p>

<pre><code>let entityDecodedContents = textContents
    .map(\.body)
    .joined()
       .replacingOccurrences(of: &quot;&amp;#x000A;&quot;, with: &quot;&quot;)
       .replacingOccurrences(of: &quot;&amp;lt;&quot;, with: &quot;&lt;&quot;)
       .replacingOccurrences(of: &quot;&amp;gt;&quot;, with: &quot;&gt;&quot;)
       .replacingOccurrences(of: &quot;&amp;quot;&quot;, with: &quot;\&quot;&quot;)
       .replacingOccurrences(of: &quot;&amp;amp;&quot;, with: &quot;&amp;&quot;)

let contentRun = shouldPreserveWhitespace ? entityDecodedContents : entityDecodedContents
    .replacingOccurrences(of: &quot;\n&quot;, with: &quot; &quot;)
    .replacingOccurrences(of: &quot;\t&quot;, with: &quot; &quot;)
</code></pre>

<p>This preserves whitespace great when the text is a direct child of the node, but doesn&rsquo;t yet handle deeper nestings. To do that, we&rsquo;ll have to pass <code>shouldPreserveWhitespace</code> as a flag to child node parsing. To keep things simple, let&rsquo;s add the flag to our <code>Parsable</code> protocol requirement:</p>

<pre><code>static func parse(context: ParsingContext, shouldPreserveWhitespace: Bool) throws -&gt; Self
</code></pre>

<p>After you make the change you&rsquo;ll have to go through all the call sites where we implement the <code>parse(...)</code> method and update them to include the new flag. At pretty much every callsite, just give a value of <code>false</code>. However, let&rsquo;s return to <code>Node</code>, specifically where we&rsquo;re parsing a child node (the first choice). Change the parse call to:</p>

<pre><code>try Node.parse(context: context, shouldPreserveWhitespace: shouldPreserveWhitespace)
</code></pre>

<p>so that we can pass it down the line. Finally, where we declare our local variable for preserving whitespace, we update that to factor in the parameter passed in:</p>

<pre><code>let shouldPreserveWhitespace = startTag.element == &quot;pre&quot; || shouldPreserveWhitespace
</code></pre>

<p>Now if we run the browser, we should see that whitespace preservation works as expected.</p>

<h3>Displaying images</h3>

<p>Let&rsquo;s add support for displaying images using the <code>&lt;img&gt;</code> tag. By default, image elements are considered to be &ldquo;inline&rdquo; (ie, <code>display: inline</code> in CSS terms), but inline images are a little complicated, so I&rsquo;ll leave those as an exercise for the reader. However, supporting block images will be a little more straightforward, so let&rsquo;s add support for that.</p>

<p>While supporting all of CSS is way, way out of scope for this tutorial, it would still be nice to leave us with a starting point, so I&rsquo;d like to add support to the <code>style</code> attribute, which we&rsquo;ll parse in a rather crude way. Once we have the style attribute parsed, we&rsquo;ll add support for <code>display: block</code> as well. Let&rsquo;s start with a type representing a style.</p>

<pre><code>struct Style {

    enum DisplayStyle { case inline, block }

    var display: DisplayStyle? {
        switch rawValue[&quot;display&quot;] {
        case &quot;inline&quot;: return .inline
        case &quot;block&quot;: return .block
        default:
            return nil
        }
    }

    private let rawValue: [String: String]

    init(rawPairs: [String: String]) {
        self.rawValue = rawPairs
    }
}
</code></pre>

<p><code>Style</code> wraps an underlying dictionary of keys and values, and adds a helper property that looks for a <code>display</code> key, returning the value interpreted as either <code>inline</code> or <code>block</code> (or <code>nil</code>, if missing or something else). Now let&rsquo;s create a style instance from a node&rsquo;s style attribute, if it exists. In an extension on <code>Node</code>, put the following:</p>

<pre><code>var styleFromAttributes: Style? {
    guard let styleAttribute = attributeDictionary[&quot;style&quot;] else { return nil }
    let stylePairs = styleAttribute.components(separatedBy: &quot;;&quot;)
</code></pre>

<p>First, we check to see if we even have a style attribute, otherwise we bail. Then, we break up the value string into substrings, which are separated by a semicolon.</p>

<pre><code>    return Style(
        rawPairs: .init(
            uniqueKeysWithValues: stylePairs
                .map { $0.components(separatedBy: &quot;:&quot;) }
                .map { ($0.first?.trimmingCharacters(in: .whitespacesAndNewlines), $0.last?.trimmingCharacters(in: .whitespacesAndNewlines)) }
                .compactMap {
                    guard let key = $0, let value = $1 else { return nil }
                    return (key, value)
                }
        )
    )
}
</code></pre>

<p>Finally, we initialize the <code>Style</code> with a dictionary, whose keys and values are found by splitting up those substrings from earlier on colons, trimming out whitespace, and finally returning them as a non-nil tuple. This code is kinda fragile would definitely be made more powerful (and extensible!) if we wrote a parser like we did for html, but I&rsquo;ll leave that as an exercise for the reader :)</p>

<p>Now that we can parse a <code>Style</code> from a node&rsquo;s attributes, the last thing we need to do is modify how we&rsquo;re sorting / grouping nodes. In the <code>Node.childNodesSortedIntoBlocks</code> property, edit the for loop to look like this:</p>

<pre><code>for node in childNodes {
    let defaultDisplayStyle: Style.DisplayStyle = node.isInlineNode ? .inline : .block 
    let display = node.styleFromAttributes?.display ?? defaultDisplayStyle
    if display == .inline {
        inlineElements.append(node)
    } else {
        addInlineElementsAsGroupIfNeeded()
        nodesToReturn.append(node)
    }
}
</code></pre>

<p>With that modification, <code>&lt;img&gt;</code> nodes that have a style attribute declaring they should be <code>display: block</code> will now be properly considered block views in our renderer, and appear accordingly. All that&rsquo;s left is to create a view that can load and display images. SwiftUI already has the a perfect view for us: <code>AsyncImage</code>, which we&rsquo;ll wrap in our own <code>ImageView</code> to customize it a little.</p>

<pre><code>struct ImageView: View {
    let node: Node
    @Environment(\.urlBuilder) var urlBuilder

    var body: some View {
        AsyncImage(url: urlBuilder(URL(string: node.attributeDictionary[&quot;src&quot;] ?? &quot;&quot;)!), content: { image in
            image
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(
                    width: node.attributeDictionary[&quot;width&quot;].flatMap(WebSize.init(rawValue:))?.dimension,
                    height: node.attributeDictionary[&quot;height&quot;].flatMap(WebSize.init(rawValue:))?.dimension
                )
        }, placeholder: {
            Color(white: 0.9).cornerRadius(4)
        })
    }
}
</code></pre>

<p>From the environment, we pull out the <code>urlBuilder</code> function we declared earlier in our view hierarchy, so that we can make sure the image&rsquo;s <code>src</code> url is an absolute url, that we&rsquo;ll then hand off to SwiftUI to load asynchronously for us. When the image is ready, we resize it and constrain it as necessary, depending on any width or height attributes of the <code>&lt;img&gt;</code> node.</p>

<pre><code>struct WebSize {
    let rawValue: String

    var dimension: CGFloat {
        // trim anything that isn&#39;t a digit, then try to parse that into an int. this ignores things like &quot;px&quot;
        CGFloat(Int(rawValue.prefix(while: \.isWholeNumber)) ?? 0)
    }
}
</code></pre>

<p><code>WebSize</code> is a small little type for extracting number values out of sizing values in html. We&rsquo;re assuming everything is measured in <code>px</code> for simplicity&rsquo;s sake. Sizing in html is a complicated topic, but you could go deep here if you wanted.</p>

<p>Finally, let&rsquo;s add a case for <code>img</code> nodes in our <code>BlocksView</code> body switch statement that uses the new image view we created:</p>

<pre><code>case &quot;img&quot;:
    ImageView(node: childNode)
</code></pre>

<p>With that, we should finally be able to see image tags with their <code>display</code> set to <code>block</code>.</p>

<h3>One last thing</h3>

<p>You may have noticed that most browsers, when given an unstyled html page, will render the body using the entire width of the browser window, and our browser does this exact same thing. However, on modern monitors, this can result in extremely long lines of text that are kind of hard to read due to their length, so the nice thing to do is to style the container with a maximum width.</p>

<p>Now that we have support for the <code>style</code> attribute, let&rsquo;s parse out the <code>max-width</code> style, if it&rsquo;s present. In the <code>Style</code> struct, add the following property:</p>

<pre><code>var maxWidth: CGFloat? {
    rawValue[&quot;max-width&quot;].map(WebSize.init(rawValue:)).map(\.dimension)
}
</code></pre>

<p>Let&rsquo;s use this property on our <code>BodyView</code>. Change the body view&rsquo;s <code>body</code> scroll view to this:</p>

<pre><code>ScrollView {
    HStack(spacing: 0) {
        BlocksView(children: bodyNode.childNodesSortedIntoBlocks)
            .frame(maxWidth: bodyNode.styleFromAttributes?.maxWidth)
        Spacer()
    }
    .padding(20)
}
</code></pre>

<p>This makes the <code>BlocksView</code> respect the <code>max-width</code> from the <code>&lt;body&gt;</code> tag, if it exists.</p>

<h2>The End</h2>

<p>This concludes our browser engine. We wrote a simple html parser from scratch with Swift, and then wrote a rendering engine using SwiftUI. In all, the browser should be capable of rendering this very tutorial, and it should look pretty much identical to how it looks in Safari, Chrome, or other Big Browsers.</p>

<p>You could extend this foundation in so many ways:</p>

<ul>
<li>You could add more block or inline elements types</li>
<li>You could expand what style elements are supported</li>
<li>You could even write your own CSS parser! or if you have limitless ambition, you could write a javascript engine too</li>
</ul>

<p>But most of all, I hope you enjoyed yourself and learned a thing or two.</p>

<p>Thanks for reading! And special thanks to Dalton Claybrook, Dean Silfen, Drew Wyatt, and Kate Brennan for all their feedback and encouragement.</p>

<p>(ps: I&rsquo;m looking for work, so if you&rsquo;re looking to hire someone to work on browsers, programming languages, dev tools, or Swift apps, I&rsquo;m your guy! <a href="mailto:i.jasonbrennan@gmail.com">Please reach out</a>, I&rsquo;d love to hear from you)</p>
